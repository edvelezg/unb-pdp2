== Abstract.  ==

One of the difficulties faced when using a general purpose 
graphing processing on memory intensive tasks, is the considerable amount 
of time taken to transfer data from a CPU.  Such is the case when one 
tries to upload a projection index from a CPU onto a GPU.  One way to 
minimize the amount of data that needs to be transferred is through the 
use of compression.  In this paper a Run Length Encoding (RLE) compression 
scheme will be used to minimize the size of the data needed to be 
transferred.  The idea is to compress a projection index using the RLE 
scheme and then uncompress it within the GPU with a parallel prefix sum 
scan which will determine how to allocate and copy the uncompressed 
projection index within the GPU.  To conclude, a benchmark test will 
compare whether there's any improvement in performance by loading 
compressed and uncompressing, as opposed to loading an uncompressed index.

Transfer a compressed projection index column and uncompress it in the 
GPU.  The compression scheme used would be RLE (Run Length Encoding) and 
the algorithm for uncompressing in parallel within the GPU should be the 
Prefix Sum algorithm.

== Introduction == The projection index supports thread-level parallelism 
and therefore could potentiall make good use of a GPU.  However, most of 
the time spent when using the index in order to do a query evaluation of a 
projection index, is spent in transferring data from the CPU to the GPU.  
Gosink et al.  improve on this bottleneck by reducing the size of the data 
that needs to be transferred, they do so by changing the encoding of the 
data that needs to be transferred.  In this paper to reduce the size of 
the data that will be transferred from the CPU to the GPU, compression is 
used.  Then after it is transferred, the index is uncompressed using an 
uncompression algorithm within the GPU itself.  

The compressed projection index is sent to the GPU as two sepparate 
arrays.  One array is the frequencies, which represent the number of times 
an attribute value repeats, and the other array is the attribute values 
themselves.  For the Run Length encoding compression scheme to be useful 
in reducing the size of the data, the projection index must be created on 
columns that are not unique and that allow themselves to be compressed 
somewhat.  After the algorithm is sent to the GPU it is uncompressed using 
an uncompression algorithm.  The algorithms that were designed to perform 
this job use the Prefix sum algorithm.  

== Parallel Prefix sum algorithm == The prefix sum algorithm is an 
essential building block for the uncompression of a projection index that 
has been previously compressed in the RLE encoding format.  #x et al.  
present methods to do so in parallel.  The article classifies two types of 
prefix sums, or scans as it calls it, inclusive and exclusive.  The 
inclusive scan generates a new array in which every element j is the sum 
of all elements up to and including j.  The exclusive scan on the other 
hand is an operation that contains the sum of all previous elements, but 
not j itself.  The first algorithm presented in the paper is the naive 
parallel scan which has a work complexity equal to sum from d = 1 to log 
base 2 n n - 2^(d-1) = O(n log base 2 n ) addition operations.  This 
scan's work complexity is even greater than the sequential scan and is not 
work-efficient.  

They first start with the naive algorithm and proceed with more advanced 
techniques to obtain the best performance.  Their first approach consists 
of 

== Design == In this paper two algorithm design approaches are presented 
for uncompressing an index in the GPU.  

== The Naive unbalanced approach ==


== The Load Balanced approach ==

== Future work ==

One possible avenue for future work is to compare the GPU's uncompression 
against the CPU, as it may not be a good algorithm for transferring an 
index quickly in the GPU, but it may be a good uncompression algorithm.  
  
