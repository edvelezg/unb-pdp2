<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CUDPP: A Simple CUDPP Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="example_simpleCUDPP">A Simple CUDPP Example </a></h1>This code sample demonstrates a basic usage of CUDPP for computing the parallel prefix sum of a floating point array on the GPU.<h2><a class="anchor" name="codeWalkthrough">
Sample Code Walkthrough</a></h2>
The simpleCUDPP sample is the "hello" world example for CUDPP. Its aim is to show you how to initialize, run, and shut down CUDPP functions.<p>
The main function in simpleCUDPP.cu is <code>runTest()</code>.<h3><a class="anchor" name="runTest">
runTest()</a></h3>
<p>
simpleCUDPP uses libCUTIL, a CUDA utility library used in NVIDIA CUDA SDK samples to initialize CUDA and to check for errors. <code>runTest</code> starts by initializing the CUDA device and then declaring the number of elements and the array size for the arrays we plan to scan. It then allocates the host-side (CPU-side) input array, <code>h_idata</code>, and initializes the data it contains with some random values between 0 and 15.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span>
runTest( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) 
{
    CUT_DEVICE_INIT(argc, argv);

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numElements = 32768;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> memSize = <span class="keyword">sizeof</span>( float) * numElements;

    <span class="comment">// allocate host memory</span>
    <span class="keywordtype">float</span>* h_idata = (<span class="keywordtype">float</span>*) malloc( memSize);
    <span class="comment">// initalize the memory</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numElements; ++i) 
    {
        h_idata[i] = (float) (rand() &amp; 0xf);
    }
</pre></div><p>
After the input data is created on the host, we allocate a device (GPU) array <code>d_idata</code> and copy the input data from the host using <code>cudaMemcpy()</code>. We also allocate a device array for the output results, <code>d_odata</code>.<p>
<div class="fragment"><pre class="fragment">
    <span class="comment">// allocate device memory</span>
    <span class="keywordtype">float</span>* d_idata;
    CUDA_SAFE_CALL( cudaMalloc( (<span class="keywordtype">void</span>**) &amp;d_idata, memSize));
    <span class="comment">// copy host memory to device</span>
    CUDA_SAFE_CALL( cudaMemcpy( d_idata, h_idata, memSize,
                                cudaMemcpyHostToDevice) );

    <span class="comment">// allocate device memory for result</span>
    <span class="keywordtype">float</span>* d_odata;
    CUDA_SAFE_CALL( cudaMalloc( (<span class="keywordtype">void</span>**) &amp;d_odata, memSize));
</pre></div><h3><a class="anchor" name="plans">
CUDPP Plans</a></h3>
Next comes the real CUDPP stuff. First we have to configure CUDPP to scan our array. Configuration of algorithms in CUDPP relies on the concept of the <em>plan</em>. A plan is a data structure that maintains intermediate storage for the algorithm, as well as information that CUDPP may use to optimize execution of the present hardware. When invoked using <a class="el" href="group__public_interface.html#g0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a>, the CUDPP planner takes the configuration details passed to it and generates an internal plan object. It returns a CUDPPHandle -- an opaque pointer type that is used to refer to the plan object -- that must be passed to other CUDPP functions in order to execute algorithms.<p>
In this case we are going to do a forward exclusive <code>float</code> sum-scan of <code>numElements</code> elements. We tell the planner this by filling out a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when...">CUDPPConfiguration</a> struct with the algorithm (CUDPP_SCAN), datatype (CUDPP_FLOAT), operation (CUDPP_ADD), and options (CUDPP_OPTION_FORWARD, CUDPP_OPTION_EXCLUSIVE). We then pass this <em>config</em> to cudppPlan along with the maximum number of elements we want to scan, <em>numElements</em>. Finally, we pass 1 and 0 for the <em>numRows</em> and <em>rowPitch</em> parameters, since we only want to scan a one-dimensional array. See the documentation for <a class="el" href="group__public_interface.html#g0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a> for more details on these parameters.<p>
<div class="fragment"><pre class="fragment">
    <a class="code" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when...">CUDPPConfiguration</a> config;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#78a6e0a90e97b79be8850ae3dff7819e" title="The numerical operator to be applied.">op</a> = <a class="code" href="cudpp_8h.html#fbc449e0243beebf799175ba0633a3862464c1df67b312f9b1461e0214ed5ade" title="Addition of two operands.">CUDPP_ADD</a>;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#8127968c4b5c05d22956e2baa41a664d" title="The datatype of the input arrays.">datatype</a> = <a class="code" href="cudpp_8h.html#8d0edad02eb8303164acb8f4abca612dfe9aa2a2ea7725eb0ea758a8dbc54399" title="Float type (C float).">CUDPP_FLOAT</a>;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#2d11e99b0c4a2b919c0bdb1c5001acfe" title="The algorithm to be used.">algorithm</a> = CUDPP_SCAN;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#32140ada5ca87b081d1cd42d29a18c11" title="Options to configure the algorithm.">options</a> = <a class="code" href="cudpp_8h.html#fdaa492f807dd46b6b529a7f962d3576f3195c0a67325a796954c781372c7e13">CUDPP_OPTION_FORWARD</a> | <a class="code" href="cudpp_8h.html#fdaa492f807dd46b6b529a7f962d357665c9029495c4bda89f73435c221cc46b">CUDPP_OPTION_EXCLUSIVE</a>;
    
    CUDPPHandle scanplan = 0;
    <a class="code" href="cudpp_8h.html#4a73ab815831334b5a7649e538ac1d0a" title="CUDPP Result codes returned by CUDPP API functions.">CUDPPResult</a> result = <a class="code" href="group__public_interface.html#g0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan</a>(&amp;scanplan, config, numElements, 1, 0);  

    <span class="keywordflow">if</span> (<a class="code" href="cudpp_8h.html#4a73ab815831334b5a7649e538ac1d0a593cd6a69fc69e6a186a2d53d4e13dbd">CUDPP_SUCCESS</a> != result)
    {
        printf(<span class="stringliteral">"Error creating CUDPPPlan\n"</span>);
        exit(-1);
    }
</pre></div><p>
We now have a handle to our plan object in <em>scanplan</em>. Next, after making sure that <a class="el" href="group__public_interface.html#g0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a> did not return an error, we put CUDPP to work by invoking <a class="el" href="group__public_interface.html#g6d637cd697e495985afbb1c3e64a21f7" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places...">cudppScan()</a>, to which we pass our plan handle, the output and input device arrays, and the number of elements to scan.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Run the scan</span>
    <a class="code" href="group__public_interface.html#g6d637cd697e495985afbb1c3e64a21f7" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places...">cudppScan</a>(scanplan, d_odata, d_idata, numElements);
</pre></div><p>
Next, we read the results of the scan from d_odata back to the host, compute a reference solution on the CPU (<code>computeSumScanGold()</code>), and compare the results for correctness.<p>
<div class="fragment"><pre class="fragment">
    <span class="comment">// allocate mem for the result on host side</span>
    <span class="keywordtype">float</span>* h_odata = (<span class="keywordtype">float</span>*) malloc( memSize);
    <span class="comment">// copy result from device to host</span>
    CUDA_SAFE_CALL( cudaMemcpy( h_odata, d_odata, memSize,
                                cudaMemcpyDeviceToHost) );
    <span class="comment">// compute reference solution</span>
    <span class="keywordtype">float</span>* reference = (<span class="keywordtype">float</span>*) malloc( memSize);
    computeSumScanGold( reference, h_idata, numElements, config);

    <span class="comment">// check result</span>
    CUTBoolean res = cutComparef( reference, h_odata, numElements);
    printf( <span class="stringliteral">"Test %s\n"</span>, (1 == res) ? <span class="stringliteral">"PASSED"</span> : <span class="stringliteral">"FAILED"</span>);
</pre></div><p>
Finally, we tell CUDPP to clean up the memory used for our plan object, using <a class="el" href="group__public_interface.html#g4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>. Then we free the host and device arrays using <code>free()</code> and <code>cudaFree</code>, respectively. After that we're finished.<p>
<div class="fragment"><pre class="fragment">
    result = <a class="code" href="group__public_interface.html#g4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a>(scanplan);
    <span class="keywordflow">if</span> (<a class="code" href="cudpp_8h.html#4a73ab815831334b5a7649e538ac1d0a593cd6a69fc69e6a186a2d53d4e13dbd">CUDPP_SUCCESS</a> != result)
    {
        printf(<span class="stringliteral">"Error destroying CUDPPPlan\n"</span>);
        exit(-1);
    }
</pre></div><p>
Using CUDPP for parallel prefix sums is easy! </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 3 16:52:27 2009 for CUDPP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
